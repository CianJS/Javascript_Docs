# 데이터 타입

* 값의 종류
* JS는 7개의 데이터 타입을 제공한다.
  * 원시 타입과 객체 타입으로 분류된다.

| 구분        | 데이터 타입                                                                                        | 설명             |
| --------- | --------------------------------------------------------------------------------------------- | -------------- |
| 원시 타입     | 숫자                                                                                            | 정수, 실수 등 모든 숫자 |
| 문자열       | 문자열                                                                                           |                |
| 불리언       | true, false                                                                                   |                |
| undefined | 선언된 변수에 암묵적으로 할당되는 값                                                                          |                |
| null      | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값                                                                  |                |
| 심벌        | ES6에서 추가된 7번째 타입                                                                              |                |
| BigInt    | <p>ES11에서 추가된 8번째 타입.<br>숫자 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.</p> |                |
| 객체 타입     | 객체, 함수, 배열 등                                                                                  |                |

## 숫자 타입

* ECMAScript의 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식
  * 즉, 모든 수를 실수로 처리한다.

숫자타입의 세 가지 특별한 값

> Infinity: 양의 무한대\
> \-Infinity: 음의 무한대\
> NaN: 산술 연산 불가(not a number)

## 문자열 타입

* 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이므로 전세계 대부분의 문자를 표현할 수 있다.
* C나 자바와는 달리 JS에서는 원시 타입임과 동시에 변경 불가능한 값(immutable value)이다.
  * 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.
* 문자열은 유사배열객체이다.
  * 문자열은 배열처럼 인덱스를 통해 개별 문자에 접근할 수 있다.
  * 문자열은 배열이 아니므로 배열의 메서드를 사용할 수 없다.

```js
// 문자열은 유사배열객체이므로 인덱스를 통해 개별 문자에 접근할 수 있다.
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 다만, 재할당을 통해 새로운 문자열을 새롭게 할당할 수는 있다.
var str = "hello";
str[0] = "H"; // 'hello'
```

## undefined 타입

* undefined는 JS 엔진이 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 두지않고 암묵적으로 초기화하는 값이다.
* JS 엔진이 변수를 초기화하는데 사용되는 undefined를 개발자가 의도적으로 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장되지 않는다. (대신 null 을 이용하자)

## 심벌(Symbol) 타입

* ES6에서 추가된 7번째 타입
* 변경이 불가능한 원시 타입의 값
* 다른 값과 절대 중복되지않는 유일무이한 값

## 데이터 타입의 필요성

* 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해
* 값을 참조할 때 한 번에 읽어야할 메모리 공간의 크기를 결정하기 위해
  * 데이터 타입에 따라 한 번에 읽어야할 메모리 공간의 크기를 모른다면 상황에 따라 데이터가 훼손되거나 너무 느리게 읽는 등의 일이 발생할 수 있다.
* 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해
  * 메모리에 저장되는 값은 2진수이다. 저장되어있는 2진수가 무엇인지 판별하기 위해서 데이터 타입을 필요하다.

> 데이터 타입을 비교하는 연산자가 있다.
>
> > [typeof 연산자](undefined-6.md#typeof-연산자)

## 타입 변환

* 명시적 타입 변환
  * 개발자가 의도적으로 타입을 변환하는 것
* 암묵적 타입 변환 (또는 타입 강제 변환)
  * 개발자가 의도하지 않았지만 타입이 암묵적으로 변환되는 것

[자세히 살펴보기](undefined-8.md)

## 객체

* JS는 프로토타입 기반 객체지향 언어이다. 아래와같은 객체 생성 방법이 있다.
  * 객체 리터럴
  * 생성자 함수
  * Object 생성자 함수
  * Object.create 메서드
  * 클래스(ES6)
* 객체는 프로퍼티와 메서드로 구성된 집합이다.
  * 프로퍼티: 객체의 상태를 나타내는 값
    * 프로퍼티는 키와 값으로 구성된다.
    * `ex) { name: 'Lee', age: 20 }` // name과 age는 프로퍼티 키, 'Lee'와 20은 프로퍼티 값이다.
  * 메서드: 객체의 상태를 참조하고 조작할 수 있는 동작
* 원시 타입의 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다.

### 객체 리터럴

* 객체 리터럴은 중괄호({})를 사용하여 객체를 생성하는 가장 간단한 방법이다.

객체의 구성 요소인 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다.\
프로퍼티 키는 식별자 네이밍 규칙을 준수하는 문자열 또는 문자열로 변환할 수 있는 표현식이어야 한다. 또는 빈 문자열이나 ES6에서 도입된 심벌 값도 프로퍼티 키로 사용할 수 있다.\
반면에 프로퍼티 값은 모든 타입의 값이 올 수 있다.

```js
const obj = {
  name: "Lee",
  name: "Kim", // 중복된 프로퍼티 키를 가진 프로퍼티는 뒤에 선언된 프로퍼티로 덮어쓰여진다.
  "first-name": "Jae", // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키는 따옴표로 감싸 문자열로 만들주어야 한다.
  1: 10, // 프로퍼티 키가 숫자 리터럴인 경우 따옴표로 감싸지 않아도 내부적으로 문자열로 변환된다.
  true: false,
  sayHi: function () {
    // ES5에서 도입된 메서드 축약 표현
    console.log("Hi");
  },
  hello() {
    // ES6에서 도입된 메서드 축약 표현
    console.log("hello");
  },
  ["1" + 2]: 12, // ES6에서 도입된 computed property name
  [Symbol()]: 10,
};
```

> 객체를 생성하는 방법은 객체 리터럴 외에도 다양한 방법이 있다.\
> 그 중에서 [생성자 함수](%EC%83%9D%EC%84%B1%EC%9E%90%20%ED%95%A8%EC%88%98md/)에 대해 궁금하다면 해당 링크를 참고해보자.

#### 프로퍼티 접근

* 프로퍼티 접근은 마침표 표기법과 대괄호 표기법이 있다.
  * 마침표 표기법(.): 프로퍼티 키가 식별자 네이밍 규칙을 준수하는 경우에만 사용할 수 있다.
  * 대괄호 표기법(\[...]): 모든 프로퍼티 키에 사용할 수 있다.

```js
const obj = {
  name: "Kim",
};
obj.name; // 'Kim'
obj["name"]; // 'Kim'
```

## 원시 타입과 객체 타입의 비교

|            | 원시 타입      | 객체 타입     |
| ---------- | ---------- | --------- |
| 변경 여부      | 변경 불가능     | 변경 가능     |
| 값의 비교      | 값 자체를 비교   | 참조 값을 비교  |
| 메모리 공간의 할당 | 스택 메모리에 할당 | 힙 메모리에 할당 |
| 변수의 할당     | 값에 의한 전달   | 참조에 의한 전달 |

### 원시 값

원시 값은 변경 불가능한 값이다. 이 말은 원시 값들은 readonly로 표현식이 평가되어 그 결과가 결정되면 변경할 수 없다는 뜻이다.\
즉, 변수에 원시 값이 할당되었다고 변수를 변경할 수 없는 것을 의미하지 않는다.\
재할당을 통해 변수 값을 변경(정확히는 교체)할 수 있다. (여기서 재할당은 메모리 공간에 저장되어있는 원시 값을 바꾸는 것이 아니다. 만약 이해가 안된다면 [다시 보러 가자](undefined-3.md#값의-할당)) 그리고 상수(const)는 값의 변경이 불가능한 것이 아니라 재할당이 금지된 변수이다. 상수에 원시 값이 할당되면 상수의 값은 변경할 수 없다. (일반적인 변수에 헷갈리지 않도록 하자)

#### 값에 의한 전달

원시 값은 변경 불가능한 값이므로 변수에 할당된 원시 값은 변경할 수 없다.

```js
let x = 1;
let y = x;
x = 10;
console.log(x, y); // 10 1
```

위 코드에서 두 번째 문까지는 x와 y는 모두 동일한 원시 값 1을 가리키고 있다.\
이때 저장되는 방식이 두 가지로 나뉠 수 있다. 첫번째는 x와 y는 같은 원시 값 1을 가지고 있지만 서로 가리키고 있는 메모리 공간이 다르다.\
조금 더 자세히 살펴보면 두 번째 문에서 변수 y가 할당될때 x는 1로 평가되어 변수 y에 1이 할당되는데, 이때 원시 값 1은 새로운 메모리 공간에 저장되고 y는 이 메모리 공간을 가리키게 된다. 이를 **값에 의한 전달**이라 한다.\
두번째는 y가 할당될때 x가 가리키고 있는 메모리 주소를 y가 가리키도록 하는 것이다. 기본적으로 변수들은 값을 기억하는 것이 아니라 값이 저장되어있는 메모리 주소를 기억한다.\
만약 재할당이 일어난다면 어떻게될까? 원시 값은 변경 불가능한 값이므로 x나 y에 재할당이 일어난다면 이미 가리키고 있는 메모리 공간의 값을 변경하는 것이 아니고 새로운 메모리 공간에 값을 저장하고 x나 y는 새로운 메모리 공간을 가리키도록 한다.\
위 코드에서 세번째 줄이 실행되면 x는 새로운 메모리 공간에 할당된 10의 메모리 주소를 가리키고 y는 1이 저장된 메모리 주소를 가리킨다.

자바스크립트 엔진이 어떻게 동작하느냐에 따라서 다르겠지만 정리하면 아래 두 가지처럼 동작할 수 있다.

1. 새로운 값을 생성해서 새로 할당된 메모리의 주소를 전달하는 방식. 이 방식은 두 변수가 같은 값을 가지고 있지만 서로 다른 메모리 공간을 가리킨다.
2. 같은 값을 가리키는 메모리 주소를 전달하는 방식. 이 방식은 두 변수가 같은 메모리 공간을 가리킨다.

### 객체 값

객체는 프로퍼티의 갯수가 미리 정해져있지 않고 필요에 따라 동적으로 추가할 수 있다. 또한 프로퍼티의 값에도 어떠한 타입의 값이든 할당할 수 있다. 때문에 원시 값과는 달리 확보해야하는 메모리 공간의 크기를 미리 결정할 수 없다.

```js
var obj = { x: 1 };
```

원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.\
하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 객체를 가리키는 **참조 값**에 접근할 수 있다.

> 참조 값은 객체가 저장된 메모리 공간의 주소를 가리키는 값이다.

원시 값은 불변성을 갖기 때문에 원시 값을 갖는 변수의 값을 변경하려면 재할당을 통해 새로운 메모리 공간에 원시 값을 새로 생성 및 저장이 이루어져야한다. 반면에 객체는 변경가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다.

```js
var obj = { x: 1 };
obj.x = 10;
console.log(obj.x); // 10
```

위 코드에서 객체를 할당한 변수 obj에 재할당을 하지 않았으므로 변수가 가리키고 있는 참조 값은 변하지않는다.\
객체도 원시 값처럼 변경이 일어날때마다 새롭게 생성한다면 신뢰성이 확보되겠지만 객체의 크기는 원시 값처럼 크기가 일정하지도 않고 그 크기가 매우 클 수도 있고 객체의 프로퍼티 값이 객체일 수도 있어서 객체를 새롭게 생성하는 것은 비용이 많이 드는 작업이다. 때문에 객체는 메모리를 효율적으로 관리하기 위해 객체를 생성한 이후에는 객체의 상태를 변경할 수 있도록 설계되었다.\
다만, 이러한 객체의 구조적인 단점에 따른 부작용이 있다. 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

> 얕은 복사와 깊은 복사
>
> > 얕은 복사(Shallow Copy)는 객체를 복사할 때 기존 값과 복사된 값이 같은 메모리 주소를 가리키고 있는 것을 말한다. 만약 객체의 프로퍼티가 객체인 경우에 참조 값을 복사하기 때문에 같은 메모리 주소를 참조한다.\
> > 깊은 복사(Deep Copy)는 원본과의 참조가 완전히 끊어지는 복사를 말한다. 이렇게 복사된 객체는 원본 객체와는 완전히 다른 메모리 주소를 가리키게 된다.
> >
> > ```js
> > // 얕은 복사
> > var obj = { x: { y: 1 } };
> > var copyObj = obj;
> > copyObj.x.y = 10;
> > console.log(obj.x.y); // 10
> > // 깊은 복사
> > var obj = { x: { y: 1 } };
> > var copyObj = JSON.parse(JSON.stringify(obj));
> > copyObj.x.y = 10;
> > console.log(obj.x.y); // 1
> > ```

#### 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라고 한다.

```js
var obj = { x: 1 };

// 참조 값을 복사
var copyObj = obj;
```

위의 코드처럼 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 저장한다. 위의 obj와 copyObj는 서로 다른 메모리 주소를 갖고 있지만 같은 참조 값을 같고 있기 때문에 동일한 객체를 가리킨다.\
이렇게 되면 원본 객체의 프로퍼티 값이 변경되면 복사된 객체의 프로퍼티 값도 변경된다.

```js
var obj = { x: 1 };
var copyObj = obj;

console.log(obj === copyObj); // true

copyObj.x = 10;
obj.y = 20;
console.log(obj); // { x: 10, y: 20 }
console.log(copyObj); // { x: 10, y: 20 }
```

위에서 언급된 **값에 의한 전달**과 **참조에 의한 전달**은 둘 다 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 즉, 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 존재한다. **참조에 의한 전달**을 다시 말하면 원시 값 대신에 참조 값이 복사되어 전달된다고 할 수 있다.\
정리해보면 '원시 값을 할당한 변수는 메모리에 원시 값을 가지고 있고 객체 값을 할당한 변수는 참조 값을 가지고 있다'라고 이야기할 수 있다.\
사실 **참조에 의한 전달**이라는 말은 알맞지않고 차라리 '참조 값을 복사해서 전달한다'라고 이해하는 것이 좋다. 실질적으로는 **값에 의한 전달**만 존재한다고 할 수 있다.
