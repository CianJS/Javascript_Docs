# 변수

- 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름
- 하나의 값을 저장하기 위한 매커니즘이지만, 배열이나 객체같은 자료구조를 사용하면 여러 개의 값을 그룹화하여 하나의 값처럼 사용할 수 있다.

> 변수명: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름  
> 변수값: 변수에 저장된 값  
> 할당: 변수에 값을 저장하는 것  
> 참조: 변수에 저장된 값을 읽어들이는 것

변수명을 사용해 참조를 요청하면 JS 엔진은 변수명과 매핑된 메모리 주소를 통해 메모리 공간에 접근하여 값을 반환하는 과정을 수행한다.

### 식별자

- 변수 이름(또는 변수명)을 식별자라고 부르기도 한다.
- 어떤 값을 구별해서 식별할 수 있는 고유한 이름이다.
- 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

즉, 메모리 주소에 붙인 이름이다.

> **식별자 네이밍**
>> 여기서 변수명을 사람이 이해할 수 있는 언어로 지어주면 가독성을 높이는 부수적인 효과가 있다.
코드는 커퓨터에게 명령을 내리는 것이기도 하지만 개발자를 위한 문서이기도 하다.
개발자의 의도를 나타내는 명확한 네이밍은 코드의 이해도를 높이고 이것은 협업 및 품질 향상에 도움이 된다.

### 변수 선언

- 변수 선언이란 변수를 생성하는 것이다.  
즉, 메모리 공간 확보 및 변수명과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 준비하는 것이다.

변수 선언시 JS에서 사용되는 키워드는 다음과같다. var, let, const
이 중에서 var는 ES6 이전에 존재하던 JS의 유일한 변수 선언 키워드이다.

>키워드
>> JS 엔진이 수행할 동작을 규정한 일종의 명령어

```js
var score;
```

위 코드는 var 키워드를 사용해 score라는 이름으로 새로운 변수를 선언할 것을 지시하는 코드이다.
이 코드가 실행이 되면 아래처럼 동작한다.

- 메모리 공간 확보 > 확보된 메모리 공간의 주소를 score 라는 식별자 이름으로 매핑 > JS 엔진에 의해 **undefined** 라는 값을 할당하여 초기화

변수를 선언한 이후, 확보된 메모리 공간에는 JS 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.

> undefined
>> JS에서 제공하는 원시 타입의 값

### 변수 호이스팅

- JS 코드는 **런타임**때 인터프리터에 의해 한 줄 씩 실행된다.
- JS 엔진은 소스코드의 평가 과정을 거치면서 실행을 위한 준비를 한다.  
평가 과정에서 변수 선언을 포함한 모든 선언문(변수, 함수, 클래스 등)을 소스코드에서 찾아내 먼저 실행한다.  
그리고 평가 과정이 끝난 뒤 모든 선언문을 제외하고 소스코드를 한줄 씩 실행한다.

위와 같은 배경을 가지고 아래 코드를 살펴보자.

```js
console.log(score); // undefined
var score;
```

위의 코드에서 console.log가 반환하는 값은 undefined이다.  
변수 선언문보다 위에 있음에도 선언을 먼저한 것처럼 보이는 이 특징을 **변수 호이스팅**이라 한다.

### 값의 할당

변수에 값을 할당할 때에는 소스코드가 순차적으로 실행되는 시점인 런타임에 동작한다.  
변수 선언이 런타임 이전에 먼저 실행되어 먼저 메모리 공간을 확보한 뒤, 변수에 값을 할당할 때에는 아래와같이 동작한다.

1. 할당하려는 값을 저장할 메모리 공간을 새롭게 확보한다.
2. 확보된 메모리 공간에 값을 저장
3. 2에서 새롭게 저장된 메모리 공간의 주소와 변수명을 새롭게 매핑한다.

위처럼 변수는 undefined에서 새로운 값으로 그값은 또다시 새로운 값으로 다시 할당할 수가 있다.  
만약 이렇게 값을 다시 할당할 수 없다면 그것은 변수가 아니라 상수(constant)라 한다.  
상수는 값이 정해지면 다시 바뀌지 않는 값이다. 즉, 한 번만 할당이 가능한 변수다. (처음에 변수 선언을 할때 메모리에 undefined가 저장되고 저장된 메모리 주소값과 변수명이 매핑되어 있다가 다음 값을 추가로 메모리에 저장하여 해당 주소값으로 다시 매핑시킬 수 있다는 것이다.)

> **가비지 콜렉터**
>> 메모리 공간에 저장되어있는 값들 중 그 어떤 식별자와도 연결되어있지 않은 경우가 있다.
예를 들어 foo라는 변수를 선언하고 30으로 값을 할당하고 그 다음에 100으로 값을 재할당한다고 가정하자.  
foo는 undefined가 저장된 메모리 주소를 갖다가 30이 저장된 메모리 주소로 다시 기억 그리고 마지막으로 100이 저장된 공간을 주소로 다시 기억한다.  
이렇게되면 undefined와 30은 그 어떤 식별자도 이 두 값을 바라보고 있지않은 상황이 되고, 이는 곧 두 값이 필요한 값이 아니라고 해석할 수 있다.  
이와같은 상황일때 가비지 콜렉터에 의해 메모리 공간에서 해제된다. 이를 통해 메모리 누수를 방지한다. 단, 언제 해제될지는 모른다.  
>> 가비지 콜렉터에 대한 흥미로운 실험: [바로가기](https://velog.io/@surim014/Experiments-with-the-JavaScript-Garbage-Collector)
---
> **언매니지드 언어, 매니지드 언어**
>> 메모리 관리 방식에 따라 두 언어로 분류할 수 있다. JS는 매니지드 언어이다.  
C와 같은 언어는 개발자가 메모리를 명시적으로 할당하고 해제하기 위한 메모리 제어 기능을 제공한다. 즉, 메모리 제어를 개발자가 주도할 수 있게된다.  
반면에 JS와같은 매니지드 언어는 메모리의 할당, 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자에게 이러한 제어 기능을 제공하지 않는다. 메모리의 해제는 가비지 콜렉터가 담당한다.
