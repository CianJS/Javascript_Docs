# 변수

- 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름
- 하나의 값을 저장하기 위한 매커니즘이지만, 배열이나 객체같은 자료구조를 사용하면 여러 개의 값을 그룹화하여 하나의 값처럼 사용할 수 있다.

> 변수명: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름\
> 변수값: 변수에 저장된 값\
> 할당: 변수에 값을 저장하는 것\
> 참조: 변수에 저장된 값을 읽어들이는 것

변수명을 사용해 참조를 요청하면 JS 엔진은 변수명과 매핑된 메모리 주소를 통해 메모리 공간에 접근하여 값을 반환하는 과정을 수행한다.

### 식별자

- 변수 이름(또는 변수명)을 식별자라고 부르기도 한다.
- 어떤 값을 구별해서 식별할 수 있는 고유한 이름이다.
- 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

즉, 메모리 주소에 붙인 이름이다.

> **식별자 네이밍**\
> 여기서 변수명을 사람이 이해할 수 있는 언어로 지어주면 가독성을 높이는 부수적인 효과가 있다. 코드는 커퓨터에게 명령을 내리는 것이기도 하지만 개발자를 위한 문서이기도 하다. 개발자의 의도를 나타내는 명확한 네이밍은 코드의 이해도를 높이고 이것은 협업 및 품질 향상에 도움이 된다.

### 변수 선언

- 변수 선언이란 변수를 생성하는 것이다.\
  즉, 메모리 공간 확보 및 변수명과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 준비하는 것이다.

변수 선언시 JS에서 사용되는 키워드는 다음과같다. var, let, const 이 중에서 var는 ES6 이전에 존재하던 JS의 유일한 변수 선언 키워드이다.

> **키워드**\
> JS 엔진이 수행할 동작을 규정한 일종의 명령어

```js
var score;
```

위 코드는 var 키워드를 사용해 score라는 이름으로 새로운 변수를 선언할 것을 지시하는 코드이다. 이 코드가 실행이 되면 아래처럼 동작한다.

- 메모리 공간 확보 > 확보된 메모리 공간의 주소를 score 라는 식별자 이름으로 매핑 > JS 엔진에 의해 **undefined** 라는 값을 할당하여 초기화

변수를 선언한 이후, 확보된 메모리 공간에는 JS 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.

> **undefined** JS에서 제공하는 원시 타입의 값

### 변수 호이스팅

- JS 코드는 **런타임**때 인터프리터에 의해 한 줄 씩 실행된다.
- JS 엔진은 소스코드의 평가 과정을 거치면서 실행을 위한 준비를 한다.\
  평가 과정에서 변수 선언을 포함한 모든 선언문(변수, 함수, 클래스 등)을 소스코드에서 찾아내 먼저 실행한다.\
  그리고 평가 과정이 끝난 뒤 모든 선언문을 제외하고 소스코드를 한줄 씩 실행한다.

위와 같은 배경을 가지고 아래 코드를 살펴보자.

```js
console.log(score); // undefined
var score;
```

위의 코드에서 console.log가 반환하는 값은 undefined이다.\
변수 선언문보다 위에 있음에도 선언을 먼저한 것처럼 보이는 이 특징을 **변수 호이스팅**이라 한다.

### 값의 할당

변수에 값을 할당할 때에는 소스코드가 순차적으로 실행되는 시점인 런타임에 동작한다.\
변수 선언이 런타임 이전에 먼저 실행되어 먼저 메모리 공간을 확보한 뒤, 변수에 값을 할당할때는 아래와같이 동작한다.

1. 할당하려는 값을 저장할 메모리 공간을 새롭게 확보한다.
2. 확보된 메모리 공간에 값을 저장
3. 2에서 새롭게 저장된 메모리 공간의 주소와 변수명을 새롭게 매핑한다.

위처럼 변수는 undefined에서 새로운 값으로 그 값은 또다시 새로운 값으로 다시 할당할 수가 있다.\
만약 이렇게 값을 다시 할당할 수 없다면 그것은 변수가 아니라 상수(constant)라 한다.\
상수는 값이 정해지면 다시 바뀌지 않는 값이다. 즉, 한 번만 할당이 가능한 변수다. (처음에 변수 선언을 할때 메모리에 undefined가 저장되고 저장된 메모리 주소값과 변수명이 매핑되어 있다가 다음 값을 추가로 메모리에 저장하여 해당 주소값으로 다시 매핑시킬 수 있다는 것이다.)

> **가비지 콜렉터**\
> 메모리 공간에 저장되어있는 값들 중 그 어떤 식별자와도 연결되어있지 않은 경우가 있다. 예를 들어 foo라는 변수를 선언하고 30으로 값을 할당하고 그 다음에 100으로 값을 재할당한다고 가정하자.\
> foo는 undefined가 저장된 메모리 주소를 갖다가 30이 저장된 메모리 주소로 다시 기억 그리고 마지막으로 100이 저장된 공간을 주소로 다시 기억한다.\
> 이렇게되면 undefined와 30은 그 어떤 식별자도 이 두 값을 바라보고 있지않은 상황이 되고, 이는 곧 두 값이 필요한 값이 아니라고 해석할 수 있다.\
> 이와같은 상황일때 가비지 콜렉터에 의해 메모리 공간에서 해제된다. 이를 통해 메모리 누수를 방지한다. 단, 언제 해제될지는 모른다.\
> 가비지 콜렉터에 대한 흥미로운 실험: [바로가기](https://velog.io/@surim014/Experiments-with-the-JavaScript-Garbage-Collector)

---

> **언매니지드 언어, 매니지드 언어**\
> 메모리 관리 방식에 따라 두 언어로 분류할 수 있다. JS는 매니지드 언어이다.\
> C와 같은 언어는 개발자가 메모리를 명시적으로 할당하고 해제하기 위한 메모리 제어 기능을 제공한다. 즉, 메모리 제어를 개발자가 주도할 수 있게 된다.\
> 반면에 JS와같은 매니지드 언어는 메모리의 할당, 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자에게 이러한 제어 기능을 제공하지 않는다. 메모리의 해제는 가비지 콜렉터가 담당한다.

## 전역 변수의 문제점

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름이다.\
즉, 변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지다. 이 정보를 바탕으로 생명 주기에 대해 살펴봅시다.

### 지역 변수의 생명 주기

```js
var x = 'global';
function foo() {
  console.log(x); // undefined
  var x = 'local';
  console.log(x);
  return x;
}
foo();
console.log(x); // ReferenceError: x is not defined
```

지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치한다. 지역 변수가 함수보다 오래 생존하는 경우도 있다.\
변수는 자신이 등록된 스코프가 소멸될 때까지 유효하다. 이 말은 곧 함수를 호출해서 생성한 스코프가 소멸할 때까지 지역 변수는 유효하다는 것이다. 또한 할당된 메모리 공간은 아무도 참조하지 않는 상태가 되어 가비지 콜렉터에 의해 메모리에서 해제된다. 이 점은 스코프에서도 동일하게 적용이 된다. 스코프를 참조하고 있으면 스코프는 소멸되지 않는다. 추가로 호이스팅은 스코프 단위로 동작한다. 전역 변수의 호이스팅은 전역 스코프의 선두로 끌어올려진 것처럼 동작한다. 지역 변수는 함수 전체에서 유효하다. 따라서 지역 변수의 호이스팅은 함수의 선두로 끌어올려진 것처럼 동작한다. 즉, 호이스팅은 변수 선언이 스코프의 선두로 끌어올려진 것처럼 동작한다.

### 전역 변수의 생명 주기

var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다. 전역 변수는 전역 객체의 프로퍼티가 된다. 그렇기때문에 이는 곧 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 의미한다.

> **전역 객체**\
> 코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 객체다. 환경에 따라 전역 객체를 가리키는 식별자가 다양했으나 ES11에서 globalThis로 통일되었다.\
> 보통 클라이언 사이드 환경에서는 window, 서버 사이드 환경에서는 global을 의미한다.

### 문제점

1. 암묵적 결합(implicit coupling)

- 변수의 유효 범위가 크면 클수록 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있다.

2. 긴 생명 주기

- 전역 변수는 생명 주기가 길기 때문에 메모리 리소스도 오랜 기간 소비한다. 전역 변수의 상태를 변경할 수 있는 시간도 길어진다. 이는 의도치 않게 상태가 변경될 수 있다는 것을 의미한다.

3. 스코프 체인 상에서 종점에 존재

- 전역 변수는 스코프 체인 상에서 종점에 존재한다. 따라서 변수 검색 속도가 가장 느리다. 전역 변수의 검색 속도가 가장 느리다는 것은 전역 변수의 사용이 빈번하다면 전체 코드의 퍼포먼스가 저하될 수 있다는 것을 의미한다.

4. 네임스페이스 오염

- 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다고 하더라도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. 이를 네임스페이스 오염이라 한다.

### 전역 변수의 사용을 억제하는 방법

1. 즉시 실행 함수

- 즉시 실행 함수는 단 한번만 호출되고 다시 호출되지 않는다. 이는 즉시 실행 함수 내에 정의된 변수는 즉시 실행 함수의 지역 변수가 된다. 따라서 전역 변수를 만들지 않는다.

```js
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
})();
console.log(foo); // ReferenceError: foo is not defined
```

2. 네임스페이스 객체

- [네임스페이스 패턴](https://velog.io/@yunsungyang-omc/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4Namespace-%EC%9D%B4%EB%A6%84%EA%B3%B5%EA%B0%84#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%8C%A8%ED%84%B4namespace-pattern)은 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.

```js
var MYAPP = {}; // 전역 네임스페이스 객체
MYAPP.name = 'Lee';
console.log(MYAPP.name); // Lee
```

3. 모듈 패턴

- 모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다.
- 모듈 패턴은 전역 변수의 억제, 캡슐화 구현, 외부에 의한 접근 제한 등의 특징을 갖는다.
  - 캡슐화(encapsulation): 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 의미한다.
  - 정보 은닉(information hiding): 모듈 패턴은 캡슐화를 통해 객체의 특정 프로퍼티나 메서드를 감출 수 있다. 즉, 외부에 공개할 필요가 없는 정보를 감출 수 있다. 이를 정보 은닉이라 표현한다.

```js
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

4. ES6 모듈

- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니다. 모듈 내에서 var 키워드로 선언한 변수는 모듈 내부에서만 유효한 지역 변수다.

```js
// lib.js
var counter = 0;
function increase() {
  return ++counter;
}
function decrease() {
  return --counter;
}
export { increase, decrease };
```

```js
// app.js
import { increase, decrease } from './lib.js';

console.log(counter); // ReferenceError: counter is not defined
console.log(increase()); // 1
console.log(increase()); // 2
console.log(decrease()); // 1
console.log(decrease()); // 0
```
