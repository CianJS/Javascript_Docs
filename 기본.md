변수는 무엇이고 왜 필요한가?
---

**사람**
- 계산과 기억을 두뇌에서 진행

**컴퓨터**
- 사람과 달리 연산과 기억을 수행하는 부품이 다름
- 연산은 CPU, 기억은 메모리에서 진행

**메모리**
- 데이터를 저장할 수 있는 **메모리 셀**의 집합체
메모리 셀
- 하나당 1바이트의 크기를 갖는다.
  - 1바이트의 크기를 갖는다는 것은 컴퓨터는 1바이트 단위로 데이터를 저장하거나 읽는다는 것
- 각 셀은 고유의 **메모리 주소**를 갖는다
  - 0부터 메모리의 크기만큼 정수로 표현
  - 모든 데이터는 2진수이다.
    - 데이터의 종류(숫자, 문자, 이미지 등)와 상관없이 2진수로 저장된다.

**메모리 제어**
- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 낳을 수 있다. (때문에 JS에서는 개발자의 직접적인 메모리 제어를 허용하지않는다.)
- 값이 저장되는 메모리 주소는 코드가 실행될때마다 메모리의 상황에 따라 임의로 결정된다.
  - 즉, 코드가 실행되기 이전에는 값이 어디에 저장된 것인지 그 메모리 주소를 알 수 없고 컴퓨터가 주소를 알려줄 수도 없다.

결론: 메모리 주소를 통해 값에 직접 접근하는 것은 좋은 방법이 아니다.

**문과 표현식**

> 필수 용어 정리
>> 값: 표현식이 평가되어 생성된 결과<br/>
>> 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용한 표기법<br/>
>> 표현식(expression): 값으로 평가될 수 있는 문<br/>
>> 문(statement): 프로그램을 구성하는 기본 단위이며 최소 실행 단위<br/>
>> 토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소. ex) var score = 2; -> var, score, =, 2, ; 가 각각 전부 토큰이다.

리터럴
- 숫자, 문자, 미리 약속된 기호('', [], {} 등)로 표기한 코드
- JS 엔진은 런타임에 리터럴을 평가해 값을 생성한다.
- 값을 생성하기 위해 미리 약속한 표기법

표현식<br/>
위 용어 정리에서 보면 값으로 평가될 수 있는 문이라고 적혀있다.<br/>
또한 바로 위에서 본 리터럴은 값으로 평가되기 때문에 **리터럴도 표현식이라 할 수 있다.**

```js
// 리터럴 표현식
8
'soomgo'

// 식별자 표현식
profile
soomgo.user

// 연산자 표현식
10 + 20
total == 100

// 함수/메서드 호출 표현식
login()
profile.dispatchUnreadChatMessageCount()
```

문<br/>
- 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

```js
// 변수 선언문
var soomgo;

// 할당문
soomgo = 100

// 함수 선언문
function foo () {}

// 조건문
if (soomgo > 10) { console.log(soomgo); }
```

**세미콜론과 ASI(Automatic Semicolon Insertion)**
- 세미콜론(;)은 문의 종료를 나타낸다.
- 문을 끝낼때는 세미콜론을 반드시 붙여야하지만, 중괄호로 묶으느 코드 블록({ ... })은 붙이지않는다.
  - 중괄호 코드 블록은 문의 종료를 의미하는 자체 종결성(self-closing)을 가지고 있기 때문
- ;을 붙이는 것은 옵셔널이다. 즉, 필수는 아니다.
  - JS 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 기능이 수행되기 때문이다. (이를 ASI라고 부른다.)

ASI는 왠만해서는 신경쓸 필요가 없을정도로 정상적으로 잘 동작하지만 예외가 있다.

```js
var bar = Functlon () {}
(function() {})();
// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {}; (function {})();
//  TypeError: (intermediate value)(...) is not a function
```

이는 JS엔진이 위에서 언급한 문의 구분이 어려운 코드이기 때문이다. 위의 예제처럼 코드가 작성이 되었다면 개발자는 ASI의 동작을 제대로 예측하지 못해 이 기능을 제대로 활용하지 못한 것이다.

**표현식인 문과 표현식이 아닌 문**

표현식인 문
- 값으로 평가될 수 있는 문

표현식이 아닌 문
- 값으로 평가될 수 없는 문

```js
// 변수 선언문은 표현식이 아닌문이다.
var x;
// 할딩문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할딩문은 표현식인 문이다.
x = 10;
// 반대로 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // Uncaught SyntaxError: Unexpected token 'var'
```

> 완료 값
>> 크롬 개발자 도구에서 어떤 문을 실행하게 되면 undefined 또는 어떤 리터럴이 출력되는 것을 볼 수 있다.<br/>
>> 여기서 표현식이 아닌 문이 실행되면 undefined를 출력하는데 이를 완료 값이라 한다.<br/>
>> 표현식인 문을 실행하면 평가된 값을 반환한다.
