# 기본지식

## 사람

- 계산과 기억을 두뇌에서 진행

## 컴퓨터

- 사람과 달리 연산과 기억을 수행하는 부품이 다름
- 연산은 CPU, 기억은 메모리에서 진행

## 메모리

- 데이터를 저장할 수 있는 **메모리 셀**의 집합체
메모리 셀
- 하나당 1바이트의 크기를 갖는다.
  - 1바이트의 크기를 갖는다는 것은 컴퓨터는 1바이트 단위로 데이터를 저장하거나 읽는다는 것
- 각 셀은 고유의 **메모리 주소**를 갖는다
  - 0부터 메모리의 크기만큼 정수로 표현
  - 모든 데이터는 2진수이다.
    - 데이터의 종류(숫자, 문자, 이미지 등)와 상관없이 2진수로 저장된다.

### 메모리 제어

- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 낳을 수 있다. (때문에 JS에서는 개발자의 직접적인 메모리 제어를 허용하지않는다.)
- 값이 저장되는 메모리 주소는 코드가 실행될때마다 메모리의 상황에 따라 임의로 결정된다.
  - 즉, 코드가 실행되기 이전에는 값이 어디에 저장된 것인지 그 메모리 주소를 알 수 없고 컴퓨터가 주소를 알려줄 수도 없다.

결론: 메모리 주소를 통해 값에 직접 접근하는 것은 좋은 방법이 아니다.

## 문과 표현식

> 필수 용어 정리
>> 값: 표현식이 평가되어 생성된 결과  
>> 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용한 표기법  
>> 표현식(expression): 값으로 평가될 수 있는 문  
>> 문(statement): 프로그램을 구성하는 기본 단위이며 최소 실행 단위  
>> 토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소.  
ex) var score = 2; -> var, score, =, 2, ; 가 각각 전부 토큰이다.

JS에는 문(statement)과 표현식(expression)이라는 개념이 있다.
아래 링크를 통해 더 자세히 살펴보자

- [문과 표현식](./%EB%AC%B8%EA%B3%BC%20%ED%91%9C%ED%98%84%EC%8B%9D.md)

### 세미콜론과 ASI(Automatic Semicolon Insertion)

- 세미콜론(;)은 문의 종료를 나타낸다.
- 문을 끝낼때는 세미콜론을 반드시 붙여야하지만, 중괄호로 묶으느 코드 블록({ ... })은 붙이지않는다.
  - [중괄호 코드 블록](./%EB%AC%B8%EA%B3%BC%20%ED%91%9C%ED%98%84%EC%8B%9D.md#블록문)은 문의 종료를 의미하는 자체 종결성(self-closing)을 가지고 있기 때문
- ;을 붙이는 것은 옵셔널이다. 즉, 필수는 아니다.
  - JS 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 기능이 수행되기 때문이다. (이를 ASI라고 부른다.)

ASI는 왠만해서는 신경쓸 필요가 없을정도로 정상적으로 잘 동작하지만 예외가 있다.

```js
var bar = Functlon () {}
(function() {})();
// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {}; (function {})();
//  TypeError: (intermediate value)(...) is not a function
```

이는 JS엔진이 위에서 언급한 문의 구분이 어려운 코드이기 때문이다. 위의 예제처럼 코드가 작성이 되었다면 개발자는 ASI의 동작을 제대로 예측하지 못해 이 기능을 제대로 활용하지 못한 것이다.

## 데이터 타입

- 값의 종류
- JS는 7개의 데이터 타입을 제공한다.
  - 원시 타입과 객체 타입으로 분류된다.

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>데이터 타입</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td rowspan=7>원시 타입</td>
        <td>숫자</td>
        <td>정수, 실수 등 모든 숫자</td>
      </tr>
      <tr>
        <td>문자열</td>
        <td>문자열</td>
      </tr>
      <tr>
        <td>불리언</td>
        <td>true, false</td>
      </tr>
      <tr>
        <td>undefined</td>
        <td>선언된 변수에 암묵적으로 할당되는 값</td>
      </tr>
      <tr>
        <td>null</td>
        <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>
      </tr>
      <tr>
        <td>심벌</td>
        <td>ES6에서 추가된 7번째 타입</td>
      </tr>
      <tr>
        <td>BigInt</td>
        <td>
          ES11에서 추가된 8번째 타입.
          <br/>숫자 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.
        </td>
      </tr>
      <tr>
        <td colspan=2>객체 타입</td>
        <td>객체, 함수, 배열 등</td>
      </tr>
  </tbody>
</table>

### 숫자 타입

- ECMAScript의 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식
  - 즉, 모든 수를 실수로 처리한다.

숫자타입의 세 가지 특별한 값
> Infinity: 양의 무한대  
> -Infinity: 음의 무한대  
> NaN: 산술 연산 불가(not a number)

### 문자열 타입

- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이므로 전세계 대부분의 문자를 표현할 수 있다.
- C나 자바와는 달리 JS에서는 원시 타입임과 동시에 변경 불가능한 값(immutable value)이다.
  - 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.

### undefined 타입

- undefined는 JS 엔진이 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 두지않고 암묵적으로 초기화하는 값이다.
- JS 엔진이 변수를 초기화하는데 사용되는 undefined를 개발자가 의도적으로 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장되지 않는다. (대신 null 을 이용하자)

### 심벌(Symbol) 타입

- ES6에서 추가된 7번째 타입
- 변경이 불가능한 원시 타입의 값
- 다른 값과 절대 중복되지않는 유일무이한 값

### 데이터 타입의 필요성

- 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어야할 메모리 공간의 크기를 결정하기 위해
  - 데이터 타입에 따라 한 번에 읽어야할 메모리 공간의 크기를 모른다면 상황에 따라 데이터가 훼손되거나 너무 느리게 읽는 등의 일이 발생할 수 있다.
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해
  - 메모리에 저장되는 값은 2진수이다. 저장되어있는 2진수가 무엇인지 판별하기 위해서 데이터 타입을 필요하다.

> 데이터 타입을 비교하는 연산자가 있다.
>> [typeof 연산자](./연산자.md#typeof-연산자)

### 타입 변환

- 명시적 타입 변환
  - 개발자가 의도적으로 타입을 변환하는 것
- 암묵적 타입 변환 (또는 타입 강제 변환)
  - 개발자가 의도하지 않았지만 타입이 암묵적으로 변환되는 것

[자세히 살펴보기](./타입변환.md)

## 연산자

- 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
- 피연산자라는 값(명사)을 연산하여(동사) 새로운 값을 만든다.

[자세히 살펴보기](./연산자.md)
