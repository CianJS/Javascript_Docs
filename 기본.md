## 기본지식

### 사람

- 계산과 기억을 두뇌에서 진행

### 컴퓨터

- 사람과 달리 연산과 기억을 수행하는 부품이 다름
- 연산은 CPU, 기억은 메모리에서 진행

### 메모리

- 데이터를 저장할 수 있는 **메모리 셀**의 집합체
메모리 셀
- 하나당 1바이트의 크기를 갖는다.
  - 1바이트의 크기를 갖는다는 것은 컴퓨터는 1바이트 단위로 데이터를 저장하거나 읽는다는 것
- 각 셀은 고유의 **메모리 주소**를 갖는다
  - 0부터 메모리의 크기만큼 정수로 표현
  - 모든 데이터는 2진수이다.
    - 데이터의 종류(숫자, 문자, 이미지 등)와 상관없이 2진수로 저장된다.

#### 메모리 제어

- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 낳을 수 있다. (때문에 JS에서는 개발자의 직접적인 메모리 제어를 허용하지않는다.)
- 값이 저장되는 메모리 주소는 코드가 실행될때마다 메모리의 상황에 따라 임의로 결정된다.
  - 즉, 코드가 실행되기 이전에는 값이 어디에 저장된 것인지 그 메모리 주소를 알 수 없고 컴퓨터가 주소를 알려줄 수도 없다.

결론: 메모리 주소를 통해 값에 직접 접근하는 것은 좋은 방법이 아니다.

### 문과 표현식

> 필수 용어 정리
>> 값: 표현식이 평가되어 생성된 결과  
>> 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용한 표기법  
>> 표현식(expression): 값으로 평가될 수 있는 문  
>> 문(statement): 프로그램을 구성하는 기본 단위이며 최소 실행 단위  
>> 토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소. ex) var score = 2; -> var, score, =, 2, ; 가 각각 전부 토큰이다.

리터럴

- 숫자, 문자, 미리 약속된 기호('', [], {} 등)로 표기한 코드
- JS 엔진은 런타임에 리터럴을 평가해 값을 생성한다.
- 값을 생성하기 위해 미리 약속한 표기법

표현식(expression)  
위 용어 정리에서 보면 값으로 평가될 수 있는 문이라고 적혀있다.  
또한 바로 위에서 본 리터럴은 값으로 평가되기 때문에 **리터럴도 표현식이라 할 수 있다.**

```js
// 리터럴 표현식
8
'soomgo'

// 식별자 표현식
profile
soomgo.user

// 연산자 표현식
10 + 20
total == 100

// 함수/메서드 호출 표현식
login()
profile.dispatchUnreadChatMessageCount()
```

문(Statement)

- 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

```js
// 변수 선언문
var soomgo;

// 할당문
soomgo = 100

// 함수 선언문
function foo () {}

// 조건문
if (soomgo > 10) { console.log(soomgo); }
```

### 세미콜론과 ASI(Automatic Semicolon Insertion)

- 세미콜론(;)은 문의 종료를 나타낸다.
- 문을 끝낼때는 세미콜론을 반드시 붙여야하지만, 중괄호로 묶으느 코드 블록({ ... })은 붙이지않는다.
  - 중괄호 코드 블록은 문의 종료를 의미하는 자체 종결성(self-closing)을 가지고 있기 때문
- ;을 붙이는 것은 옵셔널이다. 즉, 필수는 아니다.
  - JS 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 기능이 수행되기 때문이다. (이를 ASI라고 부른다.)

ASI는 왠만해서는 신경쓸 필요가 없을정도로 정상적으로 잘 동작하지만 예외가 있다.

```js
var bar = Functlon () {}
(function() {})();
// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {}; (function {})();
//  TypeError: (intermediate value)(...) is not a function
```

이는 JS엔진이 위에서 언급한 문의 구분이 어려운 코드이기 때문이다. 위의 예제처럼 코드가 작성이 되었다면 개발자는 ASI의 동작을 제대로 예측하지 못해 이 기능을 제대로 활용하지 못한 것이다.

### 표현식인 문과 표현식이 아닌 문

표현식인 문

- 값으로 평가될 수 있는 문

표현식이 아닌 문

- 값으로 평가될 수 없는 문

```js
// 변수 선언문은 표현식이 아닌문이다.
var x;
// 할딩문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할딩문은 표현식인 문이다.
x = 10;
// 반대로 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // Uncaught SyntaxError: Unexpected token 'var'
```

> 완료 값
>> 크롬 개발자 도구에서 어떤 문을 실행하게 되면 undefined 또는 어떤 리터럴이 출력되는 것을 볼 수 있다.  
>> 여기서 표현식이 아닌 문이 실행되면 undefined를 출력하는데 이를 완료 값이라 한다.  
>> 표현식인 문을 실행하면 평가된 값을 반환한다.

### 데이터 타입

- 값의 종류
- JS는 7개의 데이터 타입을 제공한다.
  - 원시 타입과 객체 타입으로 분류된다.

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>데이터 타입</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td rowspan=7>원시 타입</td>
        <td>숫자</td>
        <td>정수, 실수 등 모든 숫자</td>
      </tr>
      <tr>
        <td>문자열</td>
        <td>문자열</td>
      </tr>
      <tr>
        <td>불리언</td>
        <td>true, false</td>
      </tr>
      <tr>
        <td>undefined</td>
        <td>선언된 변수에 암묵적으로 할당되는 값</td>
      </tr>
      <tr>
        <td>null</td>
        <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>
      </tr>
      <tr>
        <td>심벌</td>
        <td>ES6에서 추가된 7번째 타입</td>
      </tr>
      <tr>
        <td>BigInt</td>
        <td>
          ES11에서 추가된 8번째 타입.
          <br/>숫자 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.
        </td>
      </tr>
      <tr>
        <td colspan=2>객체 타입</td>
        <td>객체, 함수, 배열 등</td>
      </tr>
  </tbody>
</table>

#### 숫자 타입

- ECMAScript의 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식
  - 즉, 모든 수를 실수로 처리한다.

숫자타입의 세 가지 특별한 값
> Infinity: 양의 무한대  
> -Infinity: 음의 무한대  
> NaN: 산술 연산 불가(not a number)

#### 문자열 타입

- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이므로 전세계 대부분의 문자를 표현할 수 있다.
- C나 자바와는 달리 JS에서는 원시 타입임과 동시에 변경 불가능한 값(immutable value)이다.
  - 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.

#### undefined 타입

- undefined는 JS 엔진이 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 두지않고 암묵적으로 초기화하는 값이다.
- JS 엔진이 변수를 초기화하는데 사용되는 undefined를 개발자가 의도적으로 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장되지 않는다. (대신 null 을 이용하자)

#### 심벌(Symbol) 타입

- ES6에서 추가된 7번째 타입
- 변경이 불가능한 원시 타입의 값
- 다른 값과 절대 중복되지않는 유일무이한 값

#### 데이터 타입의 필요성

- 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어야할 메모리 공간의 크기를 결정하기 위해
  - 데이터 타입에 따라 한 번에 읽어야할 메모리 공간의 크기를 모른다면 상황에 따라 데이터가 훼손되거나 너무 느리게 읽는 등의 일이 발생할 수 있다.
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해
  - 메모리에 저장되는 값은 2진수이다. 저장되어있는 2진수가 무엇인지 판별하기 위해서 데이터 타입을 필요하다.

> typeof 연산자
>> typeof 연산자는 아래와같이 사용할 수 있다.  
>> typeof <피연산자(변수, 또는 리터럴)>  
>> typeof 연산자로 변수를 연산하면 변수의 데이터 타입을 반환한다.  
>> 더 정확히 이야기하면 변수에 할당된 값의 데이터 타입을 반환한다.  
>> 변수는 메모리 주소를 알고있을뿐인 식별자이기때문
